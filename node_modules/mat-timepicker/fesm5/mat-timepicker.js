import { __read, __decorate, __param } from 'tslib';
import { NgControl, NgForm, FormGroupDirective } from '@angular/forms';
import { EventEmitter, Inject, Output, Component, Optional, Self, Renderer2, NgZone, ElementRef, Input, HostBinding, HostListener, Directive, ChangeDetectionStrategy, NgModule } from '@angular/core';
import { MAT_DIALOG_DATA, MatDialog, MatDialogModule } from '@angular/material/dialog';
import { MatFormField, MatFormFieldControl } from '@angular/material/form-field';
import { Subject } from 'rxjs';
import { takeUntil, first } from 'rxjs/operators';
import { FocusMonitor } from '@angular/cdk/a11y';
import { coerceBooleanProperty } from '@angular/cdk/coercion';
import { ErrorStateMatcher } from '@angular/material/core';
import { Platform } from '@angular/cdk/platform';
import { MatButtonModule } from '@angular/material/button';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { CommonModule } from '@angular/common';

function twoDigits(n) {
    return n < 10 ? "0" + n : "" + n;
}
function addDays(date, days) {
    var result = new Date(date);
    result.setDate(result.getDate() + days);
    return result;
}
function convertHoursForMode(hour, mode) {
    var isPm = hour >= 12;
    if (mode === '24h') {
        return { hour: hour, isPm: isPm };
    }
    else if (hour === 0 || hour === 12) {
        return { hour: 12, isPm: isPm };
    }
    else if (hour < 12) {
        return { hour: hour, isPm: isPm };
    }
    return { hour: hour - 12, isPm: isPm };
}
function mod(a, b) {
    return a - Math.floor(a / b) * b;
}
function getShortestAngle(from, to) {
    var difference = to - from;
    return from + mod(difference + 180, 360) - 180;
}
function isDateInRange(minDate, maxDate, current) {
    var unixCurrentDate = +current;
    return (!minDate || +minDate <= unixCurrentDate) && (!maxDate || unixCurrentDate <= +maxDate);
}
function isTimeInRange(minDate, maxDate, current) {
    if (minDate instanceof Date) {
        var newMinDate = new Date();
        newMinDate.setHours(minDate.getHours());
        newMinDate.setMinutes(minDate.getMinutes());
        newMinDate.setSeconds(0);
        newMinDate.setMilliseconds(0);
        minDate = newMinDate;
    }
    if (maxDate instanceof Date) {
        var newMaxDate = new Date();
        newMaxDate.setHours(maxDate.getHours());
        newMaxDate.setMinutes(maxDate.getMinutes());
        newMaxDate.setSeconds(0);
        newMaxDate.setMilliseconds(0);
        maxDate = newMaxDate;
    }
    if (current instanceof Date) {
        var newCurrent = new Date();
        newCurrent.setHours(current.getHours());
        newCurrent.setMinutes(current.getMinutes());
        newCurrent.setSeconds(0);
        newCurrent.setMilliseconds(0);
        current = newCurrent;
    }
    var unixCurrentDate = +current;
    return (!minDate || +minDate <= unixCurrentDate) && (!maxDate || unixCurrentDate <= +maxDate);
}
// used when generating the allowed maps
function isAllowed(hour, minutes, minDate, maxDate, clockMode, selectedMeridiem) {
    if (hour > 24 || hour < 0 || minutes > 60 || minutes < 0) {
        return false;
    }
    if (!minDate && !maxDate) {
        return true;
    }
    if (clockMode === '12h') {
        if (hour === 12 && selectedMeridiem === 'AM') {
            hour = 0;
        }
        if (hour > 12) {
            hour -= 12;
        }
    }
    var checkDate = new Date();
    checkDate.setHours(hour);
    checkDate.setMinutes(minutes);
    checkDate.setSeconds(0);
    checkDate.setMilliseconds(0);
    return isDateInRange(minDate, maxDate, checkDate);
}
// used by the clock component to visually disable the not allowed values
function getIsAvailabeFn(allowed12HourMap, allowed24HourMap, mode) {
    return function (value, viewType, isPm, h) {
        var isHourCheck = viewType === 'hours';
        var _a = __read(isHourCheck ? [value, null] : [h, value], 2), hour = _a[0], minutes = _a[1];
        if (mode === '12h') {
            if (!allowed12HourMap) {
                return true;
            }
            var meridiem = isPm ? 'pm' : 'am';
            if (isHourCheck) {
                return !!Object.values(allowed12HourMap[meridiem][hour]).find(function (v) { return v === true; });
            }
            return allowed12HourMap[meridiem][hour][minutes];
        }
        if (!allowed24HourMap) {
            return true;
        }
        if (isHourCheck) {
            return !!Object.values(allowed24HourMap[hour]).find(function (v) { return v === true; });
        }
        return allowed24HourMap[hour][minutes];
    };
}

var MatTimepickerComponentDialogComponent = /** @class */ (function () {
    function MatTimepickerComponentDialogComponent(data) {
        this.data = data;
        this.twoDigits = twoDigits;
        this.changeEvent = new EventEmitter();
        this.okClickEvent = new EventEmitter();
        this.cancelClickEvent = new EventEmitter();
        this.allowed24HourMap = null;
        this.allowed12HourMap = null;
        this.invalidSelection = false;
        this.viewType = 'hours';
        this.isPm = false;
        this.skipMinuteAutoSwitch = false;
        this.autoSwitchID = null;
        this.invalidMedianID = null;
        this.hasInvalidMeridiem = false;
        this.editHoursClicked = false;
        this.isClosing = false;
        this.isPm = data.isPm;
        this.bindData(data);
        // keep this always at the bottom
        this.value = data.value;
    }
    Object.defineProperty(MatTimepickerComponentDialogComponent.prototype, "value", {
        get: function () { return this._value; },
        set: function (value) {
            value = value || this.minDate || this.maxDate || new Date();
            this.hours = value.getHours();
            this.minutes = value.getMinutes();
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerComponentDialogComponent.prototype, "hours", {
        get: function () { return this._hours; },
        set: function (value) {
            this._hours = value;
            this._formattedHour = convertHoursForMode(this.hours, this.mode).hour;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerComponentDialogComponent.prototype, "formattedHours", {
        get: function () { return this._formattedHour; },
        enumerable: true,
        configurable: true
    });
    MatTimepickerComponentDialogComponent.prototype.bindData = function (data) {
        this.mode = data.mode;
        this.okLabel = data.okLabel;
        this.cancelLabel = data.cancelLabel;
        this.color = data.color;
        this.minDate = data.minDate;
        this.maxDate = data.maxDate;
        this.allowed12HourMap = data.allowed12HourMap;
        this.allowed24HourMap = data.allowed24HourMap;
    };
    MatTimepickerComponentDialogComponent.prototype.ngDoCheck = function () { this.bindData(this.data); };
    MatTimepickerComponentDialogComponent.prototype.handleClockChange = function (_a) {
        var value = _a.value, type = _a.type;
        var is24hoursAutoMeridiemChange = this.mode === '24h' && type === 'hours' && ((this.hours >= 12 && value < 12) || (this.hours < 12 && value >= 12));
        if ((this.hasInvalidMeridiem && this.mode === '12h') || is24hoursAutoMeridiemChange) {
            this.isPm = !this.isPm;
            this.hasInvalidMeridiem = false;
        }
        if ((type && type === 'hours') || (!type && this.viewType === 'hours')) {
            this.hours = value;
        }
        else if ((type && type === 'minutes') || (!type && this.viewType === 'minutes')) {
            this.minutes = value;
        }
        var newValue = new Date();
        var hours = this.isPm ? this.hours < 12 ? this.hours + 12 : this.hours : this.hours === 12 ? 0 : this.hours;
        newValue.setHours(hours);
        newValue.setMinutes(this.minutes);
        newValue.setSeconds(0);
        newValue.setMilliseconds(0);
        this.value = newValue;
        this.changeEvent.emit(newValue);
    };
    MatTimepickerComponentDialogComponent.prototype.clearInvalidMeridiem = function () {
        this.hasInvalidMeridiem = false;
    };
    MatTimepickerComponentDialogComponent.prototype.handleUnavailableSelection = function () {
        clearTimeout(this.autoSwitchID);
    };
    MatTimepickerComponentDialogComponent.prototype.handleClockChangeDone = function (e) {
        var _this = this;
        e.preventDefault(); // prevent mouseUp after touchEnd
        if (this.viewType === 'hours' && !this.skipMinuteAutoSwitch) {
            this.autoSwitchID = setTimeout(function () {
                _this.editMinutes();
                _this.autoSwitchID = null;
            }, 300);
        }
    };
    MatTimepickerComponentDialogComponent.prototype.editHours = function () {
        var _this = this;
        this.viewType = 'hours';
        this.editHoursClicked = true;
        setTimeout(function () { _this.editHoursClicked = false; }, 0);
    };
    MatTimepickerComponentDialogComponent.prototype.editMinutes = function () {
        if (this.hasInvalidMeridiem) {
            this.isPm = !this.isPm;
            this.hasInvalidMeridiem = false;
        }
        this.viewType = 'minutes';
    };
    MatTimepickerComponentDialogComponent.prototype.invalidSelectionHandler = function (value) {
        this.invalidSelection = value;
    };
    MatTimepickerComponentDialogComponent.prototype.invalidMeridiem = function () {
        var _this = this;
        if (this.viewType !== 'minutes' && this.editHoursClicked) {
            if (this.invalidMedianID) {
                return;
            }
            this.invalidMedianID = setTimeout(function () {
                _this.isPm = !_this.isPm;
                _this.hasInvalidMeridiem = false;
            }, 0);
            return;
        }
        this.hasInvalidMeridiem = true;
    };
    MatTimepickerComponentDialogComponent.prototype.meridiemChange = function (hours) {
        var changeData = {
            type: this.viewType,
            value: this.viewType === 'hours' ? hours : this.value.getMinutes()
        };
        this.handleClockChange(changeData);
    };
    MatTimepickerComponentDialogComponent.prototype.setAm = function () {
        if (this.hours >= 12) {
            this.hours = this.hours - 12;
        }
        this.isPm = false;
        this.meridiemChange(this.hours);
    };
    MatTimepickerComponentDialogComponent.prototype.setPm = function () {
        if (this.hours < 12) {
            this.hours = this.hours + 12;
        }
        this.isPm = true;
        this.meridiemChange(this.hours);
    };
    MatTimepickerComponentDialogComponent.prototype.okClickHandler = function () {
        if (this.hasInvalidMeridiem) {
            this.isPm = !this.isPm;
            this.hasInvalidMeridiem = false;
        }
        this.okClickEvent.emit();
    };
    MatTimepickerComponentDialogComponent.prototype.cancelClickHandler = function () {
        this.cancelClickEvent.emit();
    };
    MatTimepickerComponentDialogComponent.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
    ]; };
    __decorate([
        Output()
    ], MatTimepickerComponentDialogComponent.prototype, "changeEvent", void 0);
    __decorate([
        Output()
    ], MatTimepickerComponentDialogComponent.prototype, "okClickEvent", void 0);
    __decorate([
        Output()
    ], MatTimepickerComponentDialogComponent.prototype, "cancelClickEvent", void 0);
    MatTimepickerComponentDialogComponent = __decorate([
        Component({
            selector: 'mat-timepicker-dialog',
            template: "<mat-dialog-content>\n  <div class=\"root\">\n    <mat-toolbar [color]=\"color\" class=\"header\">\n      <div class=\"placeholder\"></div>\n      <div class=\"time-frame\">\n        <span class=\"time fixed-font-size\" [ngClass]=\"{'select': this.viewType === 'hours' && 'active' }\"\n          (click)=\"editHours()\">\n          {{ twoDigits(formattedHours) }}\n        </span>\n        <span class=\"fixed-font-size\">:</span>\n        <span class=\"time fixed-font-size\" [ngClass]=\"{ 'select': this.viewType === 'minutes' && 'active' }\"\n          (click)=\"editMinutes()\">\n          {{ twoDigits(minutes) }}\n        </span>\n      </div>\n      <ng-container *ngIf=\"mode === '12h' then ampm else normal\"></ng-container>\n      <ng-template #normal>\n        <div class=\"placeholder\"></div>\n      </ng-template>\n      <ng-template #ampm>\n        <div class=\"ampm\">\n          <span class=\"time\" [ngClass]=\"{ 'select': isPm }\" (click)=\"setPm()\">PM</span>\n          <span class=\"time\" [ngClass]=\"{ 'select': !isPm }\" (click)=\"setAm()\">AM</span>\n        </div>\n      </ng-template>\n    </mat-toolbar>\n    <div class=\"body\">\n      <mat-clock [allowed12HourMap]=\"allowed12HourMap\" [allowed24HourMap]=\"allowed24HourMap\" [minDate]=\"minDate\"\n        [maxDate]=\"maxDate\" [color]=\"color\" [viewType]=\"viewType\" [mode]=\"mode\" [formattedHours]=\"formattedHours\"\n        [minutes]=\"minutes\" (changeEvent)=\"handleClockChange($event)\"\n        (unavailableSelection)=\"handleUnavailableSelection()\"\n        [formattedValue]=\"viewType === 'minutes' ? minutes : formattedHours\" [isPm]=\"isPm\"\n        (invalidMeridiem)=\"invalidMeridiem()\" (mouseup)=\"handleClockChangeDone($event)\"\n        (clearInvalidMeridiem)=\"clearInvalidMeridiem()\" (touchend)=\"handleClockChangeDone($event)\"\n        (invalidSelection)=\"invalidSelectionHandler($event)\"></mat-clock>\n    </div>\n  </div>\n</mat-dialog-content>\n<mat-dialog-actions>\n  <button mat-button i18n=\"mat-timepicker|Material Timepicker Cancel Button Text\" [color]=\"color\"\n    (click)=\"cancelClickHandler()\">{{cancelLabel}}</button>\n  <button mat-button i18n=\"mat-timepicker|Material Timepicker Ok Button Text\" [disabled]=\"invalidSelection\"\n    [color]=\"color\" (click)=\"okClickHandler()\">{{okLabel}}</button>\n</mat-dialog-actions>",
            styles: ["mat-dialog-content{min-height:395px;padding:0;margin-top:-24px;overflow:hidden}mat-dialog-actions{justify-content:flex-end;margin-right:-8px;margin-left:-8px}.root{min-width:282px}.header{border-top-left-radius:2px;border-top-right-radius:2px;padding:20px 0;line-height:58px;font-size:58px;display:flex;justify-content:center;align-items:center;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;height:98px}.header .fixed-font-size{font-size:58px}.header .time-frame{height:60px}.time{transition:.2s ease-out;cursor:pointer}.time:not(.select){opacity:.6}.placeholder{flex:1}.ampm{display:flex;flex-direction:column-reverse;flex:1;font-size:14px;line-height:20px;margin-left:16px;font-weight:700px}.select{color:#fff}.body{padding:24px 16px 20px;display:flex;justify-content:center}"]
        }),
        __param(0, Inject(MAT_DIALOG_DATA))
    ], MatTimepickerComponentDialogComponent);
    return MatTimepickerComponentDialogComponent;
}());

var MatTimepickerDirective = /** @class */ (function () {
    function MatTimepickerDirective(ngControl, dialog, renderer, zone, fm, elRef, ngZone, 
    // tslint:disable-next-line:variable-name
    _platform, 
    // tslint:disable-next-line:variable-name
    _parentForm, 
    // tslint:disable-next-line:variable-name
    _matFormFiled, 
    // tslint:disable-next-line:variable-name
    _parentFormGroup, 
    // tslint:disable-next-line:variable-name
    _defaultErrorStateMatcher) {
        var _this = this;
        this.ngControl = ngControl;
        this.dialog = dialog;
        this.renderer = renderer;
        this.zone = zone;
        this.fm = fm;
        this.elRef = elRef;
        this.ngZone = ngZone;
        this._platform = _platform;
        this._parentForm = _parentForm;
        this._matFormFiled = _matFormFiled;
        this._parentFormGroup = _parentFormGroup;
        // tslint:disable-next-line:variable-name
        this._errorState = false;
        // tslint:disable-next-line:variable-name
        this._disabled = false;
        // tslint:disable-next-line:variable-name
        this._readonly = false;
        this.isAlive = new Subject();
        this.stateChanges = new Subject();
        // tslint:disable-next-line:variable-name
        this._uid = "mat-input-" + MatTimepickerDirective_1.nextId++;
        this.describedBy = '';
        // tslint:disable-next-line:variable-name
        this._required = false;
        this.focused = false;
        this.allowed24HourMap = null;
        this.allowed12HourMap = null;
        this.isInputFocused = false;
        /** Override the label of the ok button. */
        this.okLabel = 'Ok';
        /** Override the label of the cancel button. */
        this.cancelLabel = 'Cancel';
        /** Sets the clock mode, 12-hour or 24-hour clocks are supported. */
        this.mode = '24h';
        this.color = 'primary';
        this.disableDialogOpenOnClick = false;
        this.strict = true;
        this.controlType = 'angular-material-timepicker';
        this.listeners = [];
        // tslint:disable-next-line:variable-name
        this._skipValueChangeEmission = true;
        this.combination = [];
        this.timeChange = new EventEmitter();
        this.invalidInput = new EventEmitter();
        this.clickHandler = function (e) {
            if ((_this.modalRef && _this.modalRef.componentInstance.isClosing) || _this.disabled || _this.disableDialogOpenOnClick) {
                return;
            }
            if (!_this.modalRef && !_this.disableDialogOpenOnClick) {
                _this.showDialog();
            }
        };
        this.handleChange = function (newValue) {
            if (!(newValue instanceof Date)) {
                return;
            }
            var v = _this.value instanceof Date ? new Date(_this.value.getTime()) : new Date();
            v.setHours(newValue.getHours());
            v.setMinutes(newValue.getMinutes());
            v.setSeconds(0);
            v.setMilliseconds(0);
            _this.currentValue = v;
        };
        this.handleOk = function () {
            if (_this.onChangeFn) {
                _this.onChangeFn(_this.currentValue);
            }
            _this.value = _this.currentValue;
            _this.modalRef.close();
        };
        this.handleCancel = function () {
            _this.modalRef.close();
        };
        this.id = this.id;
        this.errorStateMatcher = _defaultErrorStateMatcher;
        if (this.ngControl != null) {
            this.ngControl.valueAccessor = this;
        }
        if (_platform.IOS) {
            ngZone.runOutsideAngular(function () {
                elRef.nativeElement.addEventListener('keyup', function (event) {
                    var el = event.target;
                    if (!el.value && !el.selectionStart && !el.selectionEnd) {
                        // Note: Just setting `0, 0` doesn't fix the issue. Setting
                        // `1, 1` fixes it for the first time that you type text and
                        // then hold delete. Toggling to `1, 1` and then back to
                        // `0, 0` seems to completely fix it.
                        el.setSelectionRange(1, 1);
                        el.setSelectionRange(0, 0);
                    }
                });
            });
        }
        this._isServer = !this._platform.isBrowser;
    }
    MatTimepickerDirective_1 = MatTimepickerDirective;
    Object.defineProperty(MatTimepickerDirective.prototype, "errorState", {
        get: function () {
            var oldState = this._errorState;
            var parent = this._parentFormGroup || this._parentForm;
            var control = this.ngControl ? this.ngControl.control : null;
            var newState = this.errorStateMatcher ? this.errorStateMatcher.isErrorState(control, parent) : oldState;
            if (newState !== oldState) {
                this._errorState = newState;
                this.stateChanges.next();
            }
            return newState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "disabled", {
        get: function () {
            if (this.ngControl && this.ngControl.disabled !== null) {
                return this.ngControl.disabled;
            }
            return this._disabled;
        },
        set: function (value) {
            this._disabled = coerceBooleanProperty(value);
            // Browsers may not fire the blur event if the input is disabled too quickly.
            // Reset from here to ensure that the element doesn't become stuck.
            if (this.focused) {
                this.focused = false;
                this.stateChanges.next();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "id", {
        get: function () { return this._id; },
        set: function (value) { this._id = value || this._uid; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "readonly", {
        get: function () { return this._readonly; },
        set: function (value) { this._readonly = coerceBooleanProperty(value); },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "shouldLabelFloat", {
        get: function () { return this.focused || !this.empty; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "required", {
        get: function () {
            return this._required;
        },
        set: function (req) {
            this._required = coerceBooleanProperty(req);
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "placeholder", {
        get: function () {
            return this._placeholder;
        },
        set: function (plh) {
            this._placeholder = plh;
            this.stateChanges.next();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "value", {
        get: function () { return this._value; },
        set: function (value) {
            if (value === this._value) {
                return;
            }
            this._value = value;
            if (!value) {
                this._formattedValueString = null;
                this.setInputElementValue(value);
                this.currentValue = value;
                return;
            }
            var _a = convertHoursForMode(value.getHours(), this.mode), hour = _a.hour, isPm = _a.isPm;
            this._isPm = isPm;
            this._formattedValueString = this.mode === '12h' ?
                hour + ":" + twoDigits(value.getMinutes()) + " " + (isPm ? 'pm' : 'am') :
                twoDigits(value.getHours()) + ":" + twoDigits(value.getMinutes());
            if (!this.isInputFocused) {
                this.setInputElementValue(this.formattedValueString);
            }
            this.currentValue = value;
            this.stateChanges.next();
            if (this._skipValueChangeEmission) {
                return;
            }
            this.timeChange.emit(this.currentValue);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "isPm", {
        get: function () { return this._isPm; },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "empty", {
        get: function () {
            return !(this.currentValue instanceof Date);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MatTimepickerDirective.prototype, "formattedValueString", {
        get: function () { return this._formattedValueString; },
        enumerable: true,
        configurable: true
    });
    MatTimepickerDirective.prototype.inputHandler = function () {
        var _a, _b;
        var value = this.elRef.nativeElement.value;
        var length = value.length;
        if (length === 0) {
            this.writeValue(null, true);
            if (this.onChangeFn) {
                this.onChangeFn(null);
            }
            return;
        }
        var meridiemResult = value.match(/am|pm/i);
        var meridiem = null;
        if (meridiemResult) {
            value = value.replace(meridiemResult[0], '');
            _a = __read(meridiemResult, 1), meridiem = _a[0];
        }
        var valueHasColumn = value.includes(':');
        var _c = __read(length === 1 ? [value, 0] :
            length === 2 && !valueHasColumn ? [value, 0] : valueHasColumn ? value.split(':') : value.split(/(\d\d)/).filter(function (v) { return v; }), 2), hours = _c[0], minutes = _c[1];
        hours = +hours;
        if (/\s/.test(minutes)) {
            var other = void 0;
            _b = __read(minutes.split(/\s/), 2), minutes = _b[0], other = _b[1];
            if (other === 'pm' && !isNaN(hours) && hours < 12) {
                hours += 12;
            }
        }
        minutes = +minutes;
        if (isNaN(hours) || isNaN(minutes)) {
            this.writeValue(null, true);
            return;
        }
        if (hours < 12 && meridiem && meridiem.toLowerCase() === 'pm') {
            hours += 12;
        }
        else if (hours > 12 && meridiem && meridiem.toLowerCase() === 'am') {
            hours -= 12;
        }
        if (this.mode === '12h' && +hours < 1) {
            hours = '1';
        }
        else {
            if (+hours > 24) {
                hours = '24';
            }
            else if (+hours < 0) {
                hours = '0';
            }
        }
        if (+minutes > 59) {
            minutes = '59';
        }
        else if (+minutes < 0) {
            minutes = '0';
        }
        var d = this.value ? new Date(this.value.getTime()) : new Date();
        d.setHours(+hours);
        d.setMinutes(+minutes);
        d.setSeconds(0);
        d.setMilliseconds(0);
        var isValueInRange = isDateInRange(this.minDate, this.maxDate, d);
        if (!isValueInRange) {
            this.invalidInput.emit();
        }
        this.writeValue(d, true);
        if (this.onChangeFn) {
            this.onChangeFn(d);
        }
    };
    MatTimepickerDirective.prototype.keydownHandler = function (event) {
        if (event.metaKey || event.ctrlKey || event.altKey) {
            this.combination = this.combination.concat(event.code);
            return;
        }
        if (!/^[0-9a-zA-Z\s]{0,1}$/.test(event.key)) {
            return;
        }
        var target = event.target;
        var tValue = target.value;
        var value = "" + tValue.slice(0, target.selectionStart) + event.key + tValue.slice(target.selectionEnd);
        if (value.match(this.pattern) || this.combination.length > 0) {
            return true;
        }
        event.preventDefault();
        event.stopImmediatePropagation();
    };
    MatTimepickerDirective.prototype.keyupHandler = function (event) {
        this.combination = this.combination.filter(function (v) { return v !== event.code; });
    };
    MatTimepickerDirective.prototype.focusHandler = function () {
        this.isInputFocused = true;
    };
    MatTimepickerDirective.prototype.focusoutHandler = function () {
        this.isInputFocused = false;
        this.setInputElementValue(this.formattedValueString);
        if (this.onTouchedFn && !this.modalRef) {
            this.onTouchedFn();
        }
    };
    MatTimepickerDirective.prototype.setDescribedByIds = function (ids) {
        this.describedBy = ids.join(' ');
    };
    MatTimepickerDirective.prototype.onContainerClick = function (event) {
        if (event.target.tagName.toLowerCase() !== 'input') {
            this.elRef.nativeElement.focus();
        }
    };
    MatTimepickerDirective.prototype.setInputElementValue = function (value) {
        var _this = this;
        Promise.resolve().then(function () {
            _this.zone.runOutsideAngular(function () {
                _this.renderer.setProperty(_this.elRef.nativeElement, 'value', value);
            });
        });
    };
    MatTimepickerDirective.prototype.validate = function () {
        var isValueInRange = this.strict ?
            isDateInRange(this.minDate, this.maxDate, this.currentValue) :
            isTimeInRange(this.minDate, this.maxDate, this.currentValue);
        return isValueInRange ? null : { dateRange: true };
    };
    MatTimepickerDirective.prototype.ngAfterViewInit = function () {
        this.listeners.push(this.renderer.listen(this._matFormFiled ? this._matFormFiled._elementRef.nativeElement : this.elRef.nativeElement, 'click', this.clickHandler));
    };
    MatTimepickerDirective.prototype.ngOnInit = function () {
        var _this = this;
        if (this._platform.isBrowser) {
            this.fm.monitor(this.elRef.nativeElement, true).subscribe(function (origin) {
                _this.focused = !!origin;
                _this.stateChanges.next();
            });
        }
        if (!this.value) {
            var hasMaxDate = !!this.maxDate;
            var hasMinDate = !!this.minDate;
            if (hasMinDate || hasMaxDate) {
                if (hasMinDate) {
                    this.minDate.setSeconds(0);
                    this.minDate.setMilliseconds(0);
                }
                if (hasMaxDate) {
                    this.maxDate.setSeconds(0);
                    this.maxDate.setMilliseconds(0);
                }
                Promise.resolve().then(function () { return _this.generateAllowedMap(); });
                if (!this.ngControl._rawValidators.find(function (v) { return v === _this; })) {
                    this.ngControl._rawValidators.push(this);
                }
            }
        }
        this._skipValueChangeEmission = false;
    };
    MatTimepickerDirective.prototype.generateAllowedMap = function () {
        var isStrictMode = this.strict && this.value instanceof Date;
        if (this.mode === '24h') {
            this.allowed24HourMap = {};
            for (var h = 0; h < 24; h++) {
                for (var m = 0; m < 60; m++) {
                    var hourMap = this.allowed24HourMap[h] || {};
                    if (isStrictMode) {
                        var currentDate = new Date(this.value.getTime());
                        currentDate.setHours(h);
                        currentDate.setMinutes(m);
                        currentDate.setSeconds(0);
                        currentDate.setMilliseconds(0);
                        hourMap[m] = isDateInRange(this.minDate, this.maxDate, currentDate);
                    }
                    else {
                        hourMap[m] = isAllowed(h, m, this.minDate, this.maxDate, '24h');
                    }
                    this.allowed24HourMap[h] = hourMap;
                }
            }
        }
        else {
            this.allowed12HourMap = { am: {}, pm: {} };
            for (var h = 0; h < 24; h++) {
                var meridiem = h < 12 ? 'am' : 'pm';
                for (var m = 0; m < 60; m++) {
                    var hour = (h > 12 ? h - 12 : h === 0 ? 12 : h);
                    var hourMap = this.allowed12HourMap[meridiem][hour] || {};
                    if (isStrictMode) {
                        var currentDate = new Date(this.value.getTime());
                        currentDate.setHours(h);
                        currentDate.setMinutes(m);
                        currentDate.setSeconds(0);
                        currentDate.setMilliseconds(0);
                        hourMap[m] = isDateInRange(this.minDate, this.maxDate, currentDate);
                    }
                    else {
                        hourMap[m] = isAllowed(h, m, this.minDate, this.maxDate, '24h');
                    }
                    this.allowed12HourMap[meridiem][hour] = hourMap;
                }
            }
        }
    };
    MatTimepickerDirective.prototype.ngOnChanges = function (simpleChanges) {
        this.pattern = this.mode === '24h' ? /^[0-9]{1,2}:?([0-9]{1,2})?$/ : /^[0-9]{1,2}:?([0-9]{1,2})?\s?(a|p)?m?$/;
        if ((simpleChanges.minDate && !simpleChanges.minDate.isFirstChange &&
            +simpleChanges.minDate.currentValue !== simpleChanges.minDate.previousValue) ||
            (simpleChanges.maxDate && !simpleChanges.maxDate.isFirstChange &&
                +simpleChanges.maxDate.currentValue !== simpleChanges.maxDate.previousValue) ||
            (simpleChanges.disableLimitBase && !simpleChanges.disableLimitBase.isFirstChange &&
                +simpleChanges.disableLimitBase.currentValue !== simpleChanges.disableLimitBase.previousValue)) {
            this.generateAllowedMap();
        }
        if (!this.modalRef || !this.modalRef.componentInstance) {
            return;
        }
        this.modalRef.componentInstance.data = {
            mode: this.mode,
            value: this.currentValue,
            okLabel: this.okLabel,
            cancelLabel: this.cancelLabel,
            color: this.color,
            isPm: this.isPm,
            minDate: this.minDate,
            maxDate: this.maxDate,
            allowed12HourMap: this.allowed12HourMap,
            allowed24HourMap: this.allowed24HourMap
        };
    };
    MatTimepickerDirective.prototype.checkValidity = function (value) {
        if (!value) {
            return false;
        }
        var hour = value.getHours();
        var minutes = value.getMinutes();
        var meridiem = this.isPm ? 'PM' : 'AM';
        return isAllowed(hour, minutes, this.minDate, this.maxDate, this.mode, meridiem);
    };
    MatTimepickerDirective.prototype.writeValue = function (value, isInnerCall) {
        var _this = this;
        if (isInnerCall === void 0) { isInnerCall = false; }
        if (!isInnerCall) {
            this._skipValueChangeEmission = true;
            Promise.resolve().then(function () { return _this._skipValueChangeEmission = false; });
        }
        if (value) {
            value.setSeconds(0);
            value.setMilliseconds(0);
        }
        if (+this.value !== +value) {
            this.value = value;
        }
    };
    MatTimepickerDirective.prototype.registerOnChange = function (fn) {
        this.onChangeFn = fn;
    };
    MatTimepickerDirective.prototype.registerOnTouched = function (fn) {
        this.onTouchedFn = fn;
    };
    MatTimepickerDirective.prototype.setDisabledState = function (isDisabled) {
        this.disabled = isDisabled;
    };
    MatTimepickerDirective.prototype.showDialog = function () {
        var _this = this;
        if (this.disabled) {
            return;
        }
        this.isInputFocused = false;
        this.modalRef = this.dialog.open(MatTimepickerComponentDialogComponent, {
            autoFocus: false,
            data: {
                mode: this.mode,
                value: this.currentValue,
                okLabel: this.okLabel,
                cancelLabel: this.cancelLabel,
                color: this.color,
                isPm: this.isPm,
                minDate: this.minDate,
                maxDate: this.maxDate,
                allowed12HourMap: this.allowed12HourMap,
                allowed24HourMap: this.allowed24HourMap
            }
        });
        var instance = this.modalRef.componentInstance;
        instance.changeEvent.pipe(takeUntil(this.isAlive)).subscribe(this.handleChange);
        instance.okClickEvent.pipe(takeUntil(this.isAlive)).subscribe(this.handleOk);
        instance.cancelClickEvent.pipe(takeUntil(this.isAlive)).subscribe(this.handleCancel);
        this.modalRef.beforeClosed().pipe(first()).subscribe(function () { return instance.isClosing = true; });
        this.modalRef.afterClosed().pipe(first()).subscribe(function () {
            if (_this.onTouchedFn) {
                _this.onTouchedFn();
            }
            _this.modalRef = null;
            _this.elRef.nativeElement.focus();
        });
        this.currentValue = this.value;
    };
    MatTimepickerDirective.prototype.ngOnDestroy = function () {
        this.isAlive.next();
        this.isAlive.complete();
        this.stateChanges.complete();
        if (this._platform.isBrowser) {
            this.fm.stopMonitoring(this.elRef.nativeElement);
        }
        this.listeners.forEach(function (l) { return l(); });
    };
    var MatTimepickerDirective_1;
    MatTimepickerDirective.nextId = 0;
    MatTimepickerDirective.ctorParameters = function () { return [
        { type: NgControl, decorators: [{ type: Optional }, { type: Self }] },
        { type: MatDialog },
        { type: Renderer2 },
        { type: NgZone },
        { type: FocusMonitor },
        { type: ElementRef },
        { type: NgZone },
        { type: Platform },
        { type: NgForm, decorators: [{ type: Optional }] },
        { type: MatFormField, decorators: [{ type: Optional }] },
        { type: FormGroupDirective, decorators: [{ type: Optional }] },
        { type: ErrorStateMatcher }
    ]; };
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "disabled", null);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "id", null);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "readonly", null);
    __decorate([
        HostBinding('class.floating')
    ], MatTimepickerDirective.prototype, "shouldLabelFloat", null);
    __decorate([
        HostBinding('attr.aria-describedby')
    ], MatTimepickerDirective.prototype, "describedBy", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "errorStateMatcher", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "required", null);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "placeholder", null);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "okLabel", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "cancelLabel", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "mode", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "color", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "disableDialogOpenOnClick", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "strict", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "minDate", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "maxDate", void 0);
    __decorate([
        Input()
    ], MatTimepickerDirective.prototype, "value", null);
    __decorate([
        Output()
    ], MatTimepickerDirective.prototype, "timeChange", void 0);
    __decorate([
        Output()
    ], MatTimepickerDirective.prototype, "invalidInput", void 0);
    __decorate([
        HostListener('input')
    ], MatTimepickerDirective.prototype, "inputHandler", null);
    __decorate([
        HostListener('keydown', ['$event'])
    ], MatTimepickerDirective.prototype, "keydownHandler", null);
    __decorate([
        HostListener('keyup', ['$event'])
    ], MatTimepickerDirective.prototype, "keyupHandler", null);
    __decorate([
        HostListener('focus')
    ], MatTimepickerDirective.prototype, "focusHandler", null);
    __decorate([
        HostListener('focusout')
    ], MatTimepickerDirective.prototype, "focusoutHandler", null);
    MatTimepickerDirective = MatTimepickerDirective_1 = __decorate([
        Directive({
            selector: 'input[matTimepicker]',
            providers: [
                { provide: MatFormFieldControl, useExisting: MatTimepickerDirective_1 }
            ],
            // tslint:disable-next-line:no-host-metadata-property
            host: {
                /**
                 * @breaking-change 8.0.0 remove .mat-form-field-autofill-control in favor of AutofillMonitor.
                 */
                // tslint:disable-next-line:object-literal-key-quotes
                'class': 'mat-input-element mat-form-field-autofill-control',
                '[class.mat-input-server]': '_isServer',
                // Native input properties that are overwritten by Angular inputs need to be synced with
                // the native input element. Otherwise property bindings for those don't work.
                '[attr.id]': 'id',
                '[attr.placeholder]': 'placeholder',
                '[disabled]': 'disabled',
                '[required]': 'required',
                '[attr.readonly]': 'readonly || null',
                '[attr.aria-invalid]': 'errorState',
                '[attr.aria-required]': 'required.toString()',
            },
            exportAs: 'matTimepicker'
        }),
        __param(0, Optional()), __param(0, Self()),
        __param(8, Optional()),
        __param(9, Optional()),
        __param(10, Optional())
    ], MatTimepickerDirective);
    return MatTimepickerDirective;
}());

var ClockComponent = /** @class */ (function () {
    function ClockComponent() {
        var _this = this;
        this.color = 'primary';
        this.changeEvent = new EventEmitter();
        this.unavailableSelection = new EventEmitter();
        this.invalidMeridiem = new EventEmitter();
        this.invalidSelection = new EventEmitter();
        this.clearInvalidMeridiem = new EventEmitter();
        this.allowed12HourMap = null;
        this.allowed24HourMap = null;
        this.isFormattedValueAllowed = true;
        this.meridiem = null;
        this.touching = false;
        this.numbers = [];
        this.secondaryNumbers = [];
        this.minuteDots = [];
        this.invalidMeridiemEmitted = true;
        this.handleTouchMove = function (e) {
            e.preventDefault(); // prevent scrolling behind the clock on iOS
            var rect = e.target.getBoundingClientRect();
            _this.movePointer(e.changedTouches[0].clientX - rect.left, e.changedTouches[0].clientY - rect.top);
        };
    }
    ClockComponent.prototype.initIsAllowedFn = function () {
        if (!this.allowed12HourMap && !this.allowed24HourMap) {
            return;
        }
        this.isAvailableFn = getIsAvailabeFn(this.allowed12HourMap, this.allowed24HourMap, this.mode);
    };
    ClockComponent.prototype.isAvailable = function (value) {
        return this.isAvailableFn ? this.isAvailableFn(value, this.viewType, this.isPm, this.formattedHours) : true;
    };
    ClockComponent.prototype.ngOnChanges = function (simpleChanges) {
        var _this = this;
        if (simpleChanges.allowed12HourMap ||
            simpleChanges.allowed24HourMap ||
            (simpleChanges.mode && !simpleChanges.mode.firstChange)) {
            this.initIsAllowedFn();
        }
        this.calculateAngule();
        this.setNumbers();
        this.meridiem = this.isPm ? 'PM' : 'AM';
        if (simpleChanges.formattedValue && (this.allowed12HourMap || this.allowed24HourMap)) {
            this.isFormattedValueAllowed = this.isAvailable(this.formattedValue);
        }
        var isSelectedTimeAvailable = (this.isAvailableFn) ?
            this.isAvailableFn(this.formattedValue, 'minutes', this.isPm, this.formattedHours) : true;
        if (this.mode === '24h' && this.viewType === 'minutes' && this.isAvailableFn) {
            var areMinitesAvailable = this.isAvailableFn(this.minutes, 'minutes', this.isPm, this.formattedHours);
            if (!areMinitesAvailable) {
                if (this.minDate && this.minDate.getMinutes() > this.minutes) {
                    setTimeout(function () { _this.changeEvent.emit({ value: _this.minDate.getMinutes(), type: 'minutes' }); });
                }
                else {
                    setTimeout(function () { _this.changeEvent.emit({ value: _this.maxDate.getMinutes(), type: 'minutes' }); });
                }
            }
        }
        if (isSelectedTimeAvailable && this.invalidMeridiemEmitted) {
            this.clearInvalidMeridiem.emit();
            this.invalidMeridiemEmitted = false;
        }
        this.invalidSelection.emit(!isSelectedTimeAvailable);
    };
    ClockComponent.prototype.calculateAngule = function () {
        this.angle = this.getPointerAngle(this.formattedValue, this.viewType);
    };
    ClockComponent.prototype.setNumbers = function () {
        var _this = this;
        if (this.viewType === 'hours') {
            if (this.mode === '12h') {
                var meridiem_1 = this.isPm ? 'pm' : 'am';
                var isAllowedFn = this.allowed12HourMap ? function (num) { return _this.allowed12HourMap[meridiem_1][num + 1][0]; } : undefined;
                this.numbers = this.getNumbers(12, { size: 256 }, isAllowedFn);
                this.secondaryNumbers = [];
                this.minuteDots = [];
            }
            else if (this.mode === '24h') {
                var isAllowedFn = this.allowed24HourMap ? function (num) { return _this.allowed24HourMap[num][0]; } : undefined;
                this.numbers = this.getNumbers(12, { size: 256 }, isAllowedFn);
                this.secondaryNumbers = this.getNumbers(12, { size: 256 - 64, start: 13 }, isAllowedFn);
                this.minuteDots = [];
            }
        }
        else {
            var meridiem_2 = this.isPm ? 'pm' : 'am';
            var isAllowedFn_1 = !!this.allowed12HourMap ? function (num) { return _this.allowed12HourMap[meridiem_2][_this.formattedHours][num]; } :
                !!this.allowed24HourMap ? function (num) { return _this.allowed24HourMap[_this.formattedHours][num]; } : undefined;
            this.numbers = this.getNumbers(12, { size: 256, start: 5, step: 5 }, isAllowedFn_1);
            this.minuteDots = this.getNumbers(60, { size: 256, start: 13 }).map(function (digit) {
                if (digit.display <= 59) {
                    digit.allowed = isAllowedFn_1 ? isAllowedFn_1(digit.display) : true;
                    return digit;
                }
                digit.display = digit.display - 60;
                digit.allowed = isAllowedFn_1 ? isAllowedFn_1(digit.display) : true;
                return digit;
            });
            this.secondaryNumbers = [];
        }
    };
    ClockComponent.prototype.disableAnimatedPointer = function () {
        this.touching = true;
    };
    ClockComponent.prototype.enableAnimatedPointer = function () {
        this.touching = false;
    };
    ClockComponent.prototype.handleTouchEnd = function (e) {
        this.handleTouchMove(e);
        this.enableAnimatedPointer();
    };
    ClockComponent.prototype.handleMouseMove = function (e) {
        // MouseEvent.which is deprecated, but MouseEvent.buttons is not supported in Safari
        if (e.buttons === 1 || e.which === 1) {
            var rect = e.target.getBoundingClientRect();
            this.movePointer(e.clientX - rect.left, e.clientY - rect.top);
        }
    };
    ClockComponent.prototype.handleClick = function (e) {
        var rect = e.target.getBoundingClientRect();
        this.movePointer(e.clientX - rect.left, e.clientY - rect.top);
    };
    ClockComponent.prototype.movePointer = function (x, y) {
        var value = this.getPointerValue(x, y, 256);
        if (!this.isAvailable(value)) {
            this.unavailableSelection.emit();
            return;
        }
        if (value !== this.formattedValue) {
            this.changeEvent.emit({ value: value, type: this.viewType !== 'minutes' ? 'hours' : 'minutes' });
            if (this.viewType !== 'minutes') {
                if (!this.isAvailable(value)) {
                    if (this.minDate && this.isAvailable(value)) {
                        this.changeEvent.emit({ value: this.minDate.getMinutes(), type: 'minutes' });
                    }
                    else if (this.maxDate && this.isAvailable(value)) {
                        this.changeEvent.emit({ value: this.maxDate.getMinutes(), type: 'minutes' });
                    }
                }
            }
        }
    };
    ClockComponent.prototype.getNumbers = function (count, _a, isAllowedFn) {
        var size = _a.size, _b = _a.start, start = _b === void 0 ? 1 : _b, _c = _a.step, step = _c === void 0 ? 1 : _c;
        return Array.apply(null, Array(count)).map(function (_, i) { return ({
            display: i * step + start,
            translateX: (size / 2 - 20) * Math.cos(2 * Math.PI * (i - 2) / count),
            translateY: (size / 2 - 20) * Math.sin(2 * Math.PI * (i - 2) / count),
            allowed: isAllowedFn ? isAllowedFn(i) : true
        }); });
    };
    ClockComponent.prototype.getPointerAngle = function (value, mode) {
        if (this.viewType === 'hours') {
            return this.mode === '12h' ? 360 / 12 * (value - 3) : 360 / 12 * (value % 12 - 3);
        }
        return 360 / 60 * (value - 15);
    };
    ClockComponent.prototype.getPointerValue = function (x, y, size) {
        var value;
        var angle = Math.atan2(size / 2 - x, size / 2 - y) / Math.PI * 180;
        if (angle < 0) {
            angle = 360 + angle;
        }
        if (this.viewType === 'hours') {
            if (this.mode === '12h') {
                value = 12 - Math.round(angle * 12 / 360);
                return value === 0 ? 12 : value;
            }
            var radius = Math.sqrt(Math.pow(size / 2 - x, 2) + Math.pow(size / 2 - y, 2));
            value = 12 - Math.round(angle * 12 / 360);
            if (value === 0) {
                value = 12;
            }
            if (radius < size / 2 - 32) {
                value = value === 12 ? 0 : value + 12;
            }
            return value;
        }
        value = Math.round(60 - 60 * angle / 360);
        return value === 60 ? 0 : value;
    };
    __decorate([
        Input()
    ], ClockComponent.prototype, "mode", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "viewType", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "color", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "formattedValue", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "minDate", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "maxDate", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "isPm", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "formattedHours", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "minutes", void 0);
    __decorate([
        Output()
    ], ClockComponent.prototype, "changeEvent", void 0);
    __decorate([
        Output()
    ], ClockComponent.prototype, "unavailableSelection", void 0);
    __decorate([
        Output()
    ], ClockComponent.prototype, "invalidMeridiem", void 0);
    __decorate([
        Output()
    ], ClockComponent.prototype, "invalidSelection", void 0);
    __decorate([
        Output()
    ], ClockComponent.prototype, "clearInvalidMeridiem", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "allowed12HourMap", void 0);
    __decorate([
        Input()
    ], ClockComponent.prototype, "allowed24HourMap", void 0);
    ClockComponent = __decorate([
        Component({
            selector: 'mat-clock',
            template: "<div class=\"root\">\n  <div class=\"circle\" (touchmove)=\"handleTouchMove($event)\" (mousemove)=\"handleMouseMove($event)\"\n    (touchstart)=\"disableAnimatedPointer()\" (mousedown)=\"disableAnimatedPointer()\" (touchend)=\"handleTouchEnd($event)\"\n    (mouseup)=\"enableAnimatedPointer()\" (click)=\"handleClick($event)\">\n    <div class=\"pointer-container\"\n      [ngClass]=\"{ 'small-pointer': mode === '24h' && viewType === 'hours' && (formattedValue === 0 || formattedValue > 12), 'animated-pointer': !touching }\"\n      [style.transform]=\"'rotate(' + angle + 'deg)'\">\n      <button mat-mini-fab [color]=\"color\" class=\"inner-dot\"></button>\n      <mat-toolbar [color]=\"color\" class=\"pointer\">\n        <button mat-mini-fab [color]=\"color\" class=\"outer-dot\"\n          [ngClass]=\" { 'outer-dot-odd': viewType === 'minutes' && formattedValue % 5 !== 0 }\">\n          <ng-container *ngIf=\"viewType === 'minutes' && formattedValue % 5 !== 0\">\u00B7</ng-container>\n        </button>\n      </mat-toolbar>\n    </div>\n    <ng-container *ngFor=\"let digit of minuteDots;\">\n      <button mat-mini-fab class=\"number minute-dot\"\n        [ngClass]=\"{ 'selected': formattedValue === digit.display || (digit.display === 0 && formattedValue === 0), 'disabled': !isAvailable(digit.display === 60 ? 0 : digit.display)}\"\n        [style.transform]=\"'translate(' + digit.translateX + 'px, ' + digit.translateY + 'px)'\">\n        <ng-container *ngIf=\"digit.display % 5 !== 0\">\u00B7</ng-container>\n      </button>\n    </ng-container>\n    <ng-container *ngFor=\"let digit of numbers;\">\n      <button mat-mini-fab [color]=\"color\" class=\"number\"\n        [ngClass]=\"{ 'selected': formattedValue === digit.display || (digit.display === 60 && formattedValue === 0), 'disabled': !isAvailable(digit.display === 60 ? 0 : digit.display)}\"\n        [style.transform]=\"'translate(' + digit.translateX + 'px, ' + digit.translateY + 'px)'\">\n        <ng-template #hoursTemplate>{{ digit.display }}</ng-template>\n        <ng-template #minutesTemplate>{{ digit.display === 60 ? '00' : digit.display }}</ng-template>\n        <ng-container *ngIf=\"viewType === 'minutes' then minutesTemplate else hoursTemplate;\"></ng-container>\n      </button>\n\n    </ng-container>\n    <ng-container *ngFor=\"let digit of secondaryNumbers;\">\n      <button mat-mini-fab [color]=\"color\" class=\"number small-number\"\n        [ngClass]=\"{ 'selected': formattedValue === digit.display || (digit.display === 24 && formattedValue === 0), 'disabled': !isAvailable(digit.display === 24 ? 0 : digit.display)}\"\n        [style.transform]=\"'translate(' + digit.translateX + 'px, ' + digit.translateY + 'px)'\">\n        {{ digit.display === 24 ? '00' : digit.display }}\n      </button>\n\n    </ng-container>\n  </div>",
            changeDetection: ChangeDetectionStrategy.OnPush,
            styles: [".root{width:256px;height:256px;cursor:default}.circle{width:256px;height:256px;border-radius:50%;position:relative;background:#ededed;cursor:pointer}.number{width:32px;height:32px;left:calc(50% - 16px);top:calc(50% - 16px);position:absolute;text-align:center;line-height:32px;cursor:pointer;font-size:14px;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;display:flex;align-items:center;justify-content:center;flex-direction:column;background-color:transparent;box-shadow:none}.number.disabled{color:rgba(1,1,1,.1)}.number:not(.selected):not(.disabled){color:rgba(0,0,0,.87)}.number:not(.disabled).minute-dot{color:rgba(1,1,1,.7)}.number:not(.disabled).minute-dot.selected{color:transparent}.small-number{font-size:12px}.small-number:not(.selected):not(.disabled){color:rgba(0,0,0,.67)}.pointer-container{width:calc(50% - 20px);height:2;position:absolute;left:50%;top:calc(50% - 1px);transform-origin:left center;pointer-events:none}.pointer-container.disabled *{background-color:transparent}.pointer{height:1px}.animated-pointer{transition:.2s ease-out}.small-pointer{width:calc(50% - 52px)}.inner-dot{position:absolute;top:-3px;left:-4px;width:8px;height:8px;border-radius:50%;box-shadow:none}.outer-dot{width:32px;height:32px;position:absolute;right:-16px;box-shadow:none;border-radius:50%;box-sizing:content-box}.outer-dot-odd{box-shadow:none;width:32px;height:32px;display:flex;align-items:center;justify-content:center;flex-direction:column}"]
        })
    ], ClockComponent);
    return ClockComponent;
}());

var MatTimepickerModule = /** @class */ (function () {
    function MatTimepickerModule() {
    }
    MatTimepickerModule = __decorate([
        NgModule({
            declarations: [
                ClockComponent,
                MatTimepickerDirective,
                MatTimepickerComponentDialogComponent
            ],
            imports: [
                CommonModule,
                MatDialogModule,
                MatButtonModule,
                MatToolbarModule,
                MatIconModule,
                MatInputModule
            ],
            exports: [
                MatTimepickerDirective
            ],
            entryComponents: [
                MatTimepickerComponentDialogComponent
            ]
        })
    ], MatTimepickerModule);
    return MatTimepickerModule;
}());

/*
 * Public API Surface of mat-timepicker
 */

/**
 * Generated bundle index. Do not edit.
 */

export { MatTimepickerDirective, MatTimepickerModule, ClockComponent as ɵa, MatTimepickerComponentDialogComponent as ɵb };
//# sourceMappingURL=mat-timepicker.js.map
